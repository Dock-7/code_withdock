<----------BRUTE FORCE APPROACH---------->


#include <bits/stdc++.h>
using namespace std;
struct TreeNode {
    int val;
    TreeNode*left;
    TreeNode*right;
    
    TreeNode(int x): val(x),left(NULL),right(NULL){}
};
int findsum(TreeNode*root,int&count){
    if(root==NULL) return 0;
    count++;
    
    int leftSum=findsum(root->left,count);
    int rightSum=findsum(root->right,count);
    
    return root->val+leftSum+rightSum;
}

int countValidNodes(TreeNode*root){
    int count=0;
    
    if(root==NULL) return 0;
    int sum=findsum(root,count);
    int result=(root->val==sum/count) ? 1:0;
    
    result+=countValidNodes(root->left);
    result+=countValidNodes(root->right);
    
    return result;
}

int main() {
    TreeNode*root=new TreeNode(4);
    root->left=new TreeNode(8);
    root->right=new TreeNode(5);
    root->left->left=new TreeNode(0);
    root->left->right=new TreeNode(1);
    root->right->right=new TreeNode(6);
    
    int k=countValidNodes(root);
    cout<<k;


    return 0;
}

<----------------OPTIMAL APPRAOCH------------->


#include <bits/stdc++.h>
using namespace std;
struct TreeNode {
    int val;
    TreeNode*left;
    TreeNode*right;
    
    TreeNode(int x): val(x),left(NULL),right(NULL){}
};
pair<int,int> findsum(TreeNode*root,int&count){
    if(root==NULL) return {0,0};
    
    auto P1=findsum(root->left,count);
    auto P2=findsum(root->right,count);
    
    int totalsum=P1.first+P2.first+root->val;
    int totalNode=P1.second+P2.second+1;
    
    if(root->val==(totalsum)/totalNode){
        count++;
    }
    
    return {totalsum,totalNode};
}

int countValidNodes(TreeNode*root){
    int count=0;
    findsum(root,count);
    return count;
}

int main() {
    TreeNode*root=new TreeNode(4);
    root->left=new TreeNode(8);
    root->right=new TreeNode(5);
    root->left->left=new TreeNode(0);
    root->left->right=new TreeNode(1);
    root->right->right=new TreeNode(6);
    
    int k=countValidNodes(root);
    cout<<k;


    return 0;
}

