<--------------------DFS: Undirected-GRAPH ------------------->

#include <bits/stdc++.h>
using namespace std;

bool DFS(int node,unordered_map<int,vector<int>>&adj,vector<bool>&visited,vector<bool>&inCurrentRecursion){
    visited[node]=true;
    inCurrentRecursion[node]=true;
    
    for(int adjNode:adj[node]){
        if(!visited[adjNode]){
           if(DFS(adjNode,adj,visited,inCurrentRecursion)){
            return true;
            }
        }
        //agar visited nahi hai toh hum aage recursion laga ke dekh lenge agar true aata hai toh cycle hai
        
        else if(inCurrentRecursion[adjNode]==true) return true;
        // agar pahle se node visited hai toh hum ye check karenge ki kya  : it is in Current Recursion means cycle hai tabhi toh current recursion me hai
    }
    inCurrentRecursion[node]=false;
    return false;
}

bool isCycleUndirectedDFS(vector<vector<int>>&edges){
    int V=edges.size();
    vector<bool>visited(V,false);
    vector<bool>inCurrentRecursion(V,false);
    unordered_map<int,vector<int>>adj;
    for(int i=0;i<V;i++){
        int u=edges[i][0];
        int v=edges[i][1];
        adj[v].push_back(u);
    }
    
    for(int i=0;i<V;i++){
        if(DFS(i,adj,visited,inCurrentRecursion)) return true;
    }
    return false;
}

int main() {
    int V = 4;
   vector<vector<int>> edges = {
    {0, 1},
    {1, 2},
    {2, 3},
    {3, 1}  // cycle here: 1 → 2 → 3 → 1
};

       
   bool ans=isCycleUndirectedDFS(edges);
   cout<<(ans==1? "cycle is Detected": "No Cycle was Found");

    return 0;
}    

<--------------------DFS: Directed-GRAPH ------------------->
#include <bits/stdc++.h>
using namespace std;

bool DFS(int node, int parent, unordered_map<int, vector<int>>& adj, vector<bool>& visited) {
    visited[node] = true;

    for (int adjNode : adj[node]) {
        if (!visited[adjNode]) {
            if (DFS(adjNode, node, adj, visited)) return true;
        } else if (adjNode != parent) {
            return true;  // Found a back edge (cycle)
        }
    }

    return false;
}

bool isCycleUndirectedDFS(int V, vector<vector<int>>& edges) {
    vector<bool> visited(V, false);
    unordered_map<int, vector<int>> adj;

    // Build undirected graph
    for (auto& edge : edges) {
        int u = edge[0];
        int v = edge[1];
        adj[u].push_back(v);
        adj[v].push_back(u);
    }

    for (int i = 0; i < V; i++) {
        if (!visited[i]) {
            if (DFS(i, -1, adj, visited)) return true;
        }
    }

    return false;
}

int main() {
    int V1 = 4;
vector<vector<int>> edges1 = {{0, 1},{1, 2},{2, 3},{3, 1}};

    int V2 = 7;
vector<vector<int>> edges2 = {{0, 1},{1, 2},{1, 3},{2, 4},{4, 5},{4, 6}};// not here we 

    bool ans1 = isCycleUndirectedDFS(V1, edges1);
    cout << (ans1 ? "Cycle is Detected\n" : "No Cycle was Found\n");

    bool ans2 = isCycleUndirectedDFS(V2, edges2);
    cout << (ans2 ? "Cycle is Detected\n" : "No Cycle was Found\n");

    return 0;
}

    
    
    
